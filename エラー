# 新人エンジニア向け：動作がうまくいかない時のログ・エラーログ確認ガイド

## はじめに

「コードを書いたのに動かない！」「エラーが出ているけど何が原因かわからない！」

このような状況に遭遇したとき、多くの新人エンジニアは焦ってしまい、あちこちのコードを変更して余計に問題を複雑にしてしまうことがあります。

しかし、**ログやエラーメッセージは問題解決のための最も重要な手がかり**です。この記事では、ログを効果的に活用してスムーズに問題を解決する方法を学んでいきましょう。

## なぜログを見ることが重要なのか？

### 1. 問題の原因を特定できる
ログには「いつ」「どこで」「何が」起きたかが記録されています。推測で問題を解決しようとするより、確実で効率的です。

### 2. 時間の短縮
適当にコードを変更して試すより、ログを見て原因を特定してから修正する方がはるかに速いです。

### 3. 学習効果が高い
エラーメッセージを読む習慣をつけることで、同じような問題に遭遇した時に素早く対応できるようになります。

## Djangoにおけるログの種類と確認場所

### 1. 開発サーバーのログ（コンソール出力）

`python manage.py runserver` を実行したターミナル/コマンドプロンプトに出力されるログです。

```bash
# 正常なリクエストの例
[03/Jan/2024 10:15:32] "GET /api/posts/ HTTP/1.1" 200 1234

# エラーが発生した例
[03/Jan/2024 10:16:45] "GET /api/posts/999/ HTTP/1.1" 404 142
Internal Server Error: /api/posts/create/
Traceback (most recent call last):
  File "/path/to/django/core/handlers/exception.py", line 55, in inner
    response = get_response(request)
  File "/path/to/django/core/handlers/base.py", line 197, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  ...
```

### 2. ブラウザの開発者ツール

**F12キー**を押して開発者ツールを開き、**Consoleタブ**を確認します。

```javascript
// JavaScript エラーの例
Uncaught TypeError: Cannot read property 'data' of undefined
    at handleResponse (script.js:25)
    at XMLHttpRequest.onload (script.js:15)

// ネットワークエラーの例
POST http://localhost:8000/api/posts/create/ 500 (Internal Server Error)
```

### 3. Django設定によるログファイル

```python
# settings.py でのログ設定例
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': 'django.log',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}
```

## エラーメッセージの読み方

### 1. エラーメッセージの構造を理解する

```python
Traceback (most recent call last):
  File "/path/to/myproject/blog/views.py", line 25, in post_detail
    post = Post.objects.get(id=post_id)
  File "/path/to/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/path/to/django/db/models/query.py", line 496, in get
    raise self.model.DoesNotExist(
blog.models.Post.DoesNotExist: Post matching query does not exist.
```

**読み方のポイント：**

1. **一番下のエラーメッセージ**から読む
   - `blog.models.Post.DoesNotExist: Post matching query does not exist.`
   - → 「指定されたPostが存在しない」

2. **Traceback（トレースバック）**で発生場所を確認
   - `File "/path/to/myproject/blog/views.py", line 25, in post_detail`
   - → 「blog/views.py の25行目、post_detail関数内」

3. **具体的なコード**を確認
   - `post = Post.objects.get(id=post_id)`
   - → 「この行でエラーが発生」

### 2. HTTPステータスコードを理解する

```bash
# よく見るステータスコード
200 OK          # 成功
400 Bad Request # リクエストが不正
401 Unauthorized # 認証が必要
403 Forbidden   # アクセス権限がない
404 Not Found   # リソースが見つからない
500 Internal Server Error # サーバー内部エラー
```

## よくあるエラーパターンと対処法

### 1. データベース関連のエラー

#### パターン1: DoesNotExist エラー
```python
# エラー例
blog.models.Post.DoesNotExist: Post matching query does not exist.

# 問題のコード
def post_detail(request, post_id):
    post = Post.objects.get(id=post_id)  # 存在しないIDを指定
    return JsonResponse({'title': post.title})

# 解決方法1: get_object_or_404 を使用
from django.shortcuts import get_object_or_404

def post_detail(request, post_id):
    post = get_object_or_404(Post, id=post_id)
    return JsonResponse({'title': post.title})

# 解決方法2: try-except を使用
def post_detail(request, post_id):
    try:
        post = Post.objects.get(id=post_id)
        return JsonResponse({'title': post.title})
    except Post.DoesNotExist:
        return JsonResponse({'error': 'Post not found'}, status=404)
```

#### パターン2: マイグレーションエラー
```bash
# エラー例
django.db.utils.ProgrammingError: column "blog_post.new_field" does not exist

# 原因：マイグレーションを実行し忘れ
# 解決方法
python manage.py makemigrations
python manage.py migrate
```

### 2. URLパターンのエラー

#### パターン1: NoReverseMatch エラー
```python
# エラー例
NoReverseMatch: Reverse for 'post-detail' with arguments '(1,)' not found.

# 問題のURL設定
urlpatterns = [
    path('posts/<int:pk>/', views.PostDetailView.as_view(), name='post-detail'),
]

# 問題のテンプレートまたはコード
url = reverse('post-detail', args=[post.id])  # pkを期待しているのにidを渡している

# 解決方法1: 引数名を合わせる
url = reverse('post-detail', args=[post.pk])

# 解決方法2: URL設定を変更
urlpatterns = [
    path('posts/<int:id>/', views.PostDetailView.as_view(), name='post-detail'),
]
```

### 3. シリアライザーのエラー

#### パターン1: バリデーションエラー
```python
# APIレスポンスでのエラー例
{
    "title": ["This field is required."],
    "content": ["This field may not be blank."]
}

# 問題の原因：必須フィールドが未入力
# 解決方法：フロントエンドで必要なデータを送信
{
    "title": "My Post Title",
    "content": "Post content here",
    "category": 1
}
```

### 4. 認証・権限エラー

#### パターン1: 認証が必要なエンドポイント
```bash
# エラー例
HTTP 401 Unauthorized
{"detail": "Authentication credentials were not provided."}

# 解決方法：認証情報を含めてリクエスト
curl -H "Authorization: Token your-auth-token" \
     http://localhost:8000/api/posts/create/
```

## デバッグに役立つテクニック

### 1. print文でのデバッグ

```python
# views.py での例
def post_create(request):
    print(f"Request method: {request.method}")
    print(f"Request data: {request.data}")
    
    serializer = PostSerializer(data=request.data)
    print(f"Serializer is valid: {serializer.is_valid()}")
    
    if serializer.is_valid():
        post = serializer.save()
        print(f"Created post: {post.id}")
        return Response(PostSerializer(post).data, status=201)
    else:
        print(f"Serializer errors: {serializer.errors}")
        return Response(serializer.errors, status=400)
```

### 2. Django Debug Toolbarの使用

```python
# settings.py（開発環境のみ）
if DEBUG:
    INSTALLED_APPS += ['debug_toolbar']
    MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']
    
    INTERNAL_IPS = ['127.0.0.1']

# urls.py
if settings.DEBUG:
    import debug_toolbar
    urlpatterns = [
        path('__debug__/', include(debug_toolbar.urls)),
    ] + urlpatterns
```

### 3. ログレベルを使い分ける

```python
import logging

logger = logging.getLogger(__name__)

def my_view(request):
    logger.debug("Debug information")      # 詳細な情報
    logger.info("General information")     # 一般的な情報
    logger.warning("Warning message")      # 警告
    logger.error("Error occurred")         # エラー
    logger.critical("Critical error")      # 重大なエラー
```

## 実践的なデバッグ手順

### ステップ1: エラーメッセージを全て読む

```python
# 悪い例：エラーメッセージを見ずに推測で修正
def post_detail(request, post_id):
    # エラーが出たから適当に try-except を追加
    try:
        post = Post.objects.get(id=post_id)
    except:
        pass  # 何も処理しない

# 良い例：エラーメッセージを確認してから対応
def post_detail(request, post_id):
    try:
        post = Post.objects.get(id=post_id)
        return JsonResponse({'title': post.title})
    except Post.DoesNotExist:
        # エラーメッセージから「Post が存在しない」と判明
        return JsonResponse(
            {'error': 'Post not found'}, 
            status=404
        )
```

### ステップ2: 段階的に問題を切り分ける

```python
# 複雑な処理で問題が起きた場合
def complex_view(request):
    # ステップごとに確認
    print("Step 1: Request received")
    data = request.data
    print(f"Step 2: Data parsed: {data}")
    
    serializer = MySerializer(data=data)
    print(f"Step 3: Serializer created")
    
    if serializer.is_valid():
        print("Step 4: Validation passed")
        instance = serializer.save()
        print(f"Step 5: Instance saved: {instance.id}")
    else:
        print(f"Step 4: Validation failed: {serializer.errors}")
        return Response(serializer.errors, status=400)
```

### ステップ3: 最小限のコードで問題を再現

```python
# 問題が複雑な場合、シンプルなバージョンで確認
def simple_test_view(request):
    # 最小限のコードで同じ処理を試す
    return JsonResponse({'message': 'Hello World'})

def minimal_post_view(request):
    posts = Post.objects.all()[:1]  # 1件だけ取得
    return JsonResponse({'count': len(posts)})
```

## チーム開発でのログ活用

### 1. エラー報告時のベストプラクティス

```markdown
## バグレポートテンプレート

### 環境
- OS: Windows 10
- Python: 3.9.7
- Django: 4.2.0

### 問題の説明
投稿作成時に500エラーが発生する

### 再現手順
1. /api/posts/create/ にPOSTリクエスト
2. 以下のデータを送信:
   ```json
   {
     "title": "Test Post",
     "content": "Test Content"
   }
   ```

### エラーログ
```
Internal Server Error: /api/posts/create/
Traceback (most recent call last):
  File "/path/to/views.py", line 25, in post_create
    category = Category.objects.get(id=data['category'])
KeyError: 'category'
```

### 期待される動作
投稿が正常に作成される
```

### 2. 本番環境でのログ管理

```python
# settings/production.py
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'ERROR',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/django/error.log',
            'maxBytes': 1024*1024*15,  # 15MB
            'backupCount': 10,
            'formatter': 'verbose',
        },
    },
    'root': {
        'level': 'INFO',
        'handlers': ['file'],
    },
}
```

## よくある初心者の間違いと対策

### 1. エラーメッセージを読まない

```python
# 間違い：エラーが出たら適当にコードを変更
def my_view(request):
    try:
        # 何かの処理
        result = some_function()
    except:
        # 何のエラーかわからないけど適当に対処
        result = None

# 正解：具体的なエラーを確認して対処
def my_view(request):
    try:
        result = some_function()
    except ValueError as e:
        logger.error(f"ValueError occurred: {e}")
        return Response({'error': 'Invalid value'}, status=400)
    except KeyError as e:
        logger.error(f"KeyError occurred: {e}")
        return Response({'error': 'Missing key'}, status=400)
```

### 2. print文を残したまま本番リリース

```python
# 開発時のデバッグコード
def my_view(request):
    print("Debug: request received")  # 本番では削除する
    data = request.data
    print(f"Debug: data = {data}")    # 本番では削除する
    
    # 本番用のログに変更
    logger.debug("Request received")
    logger.debug(f"Request data: {data}")
```

### 3. エラーを隠してしまう

```python
# 間違い：エラーを隠す
def my_view(request):
    try:
        post = Post.objects.get(id=999)
    except:
        pass  # エラーを無視（問題を隠すだけ）

# 正解：適切にエラーハンドリング
def my_view(request):
    try:
        post = Post.objects.get(id=999)
        return Response(PostSerializer(post).data)
    except Post.DoesNotExist:
        logger.warning(f"Post with id 999 not found")
        return Response(
            {'error': 'Post not found'}, 
            status=404
        )
```

## まとめ

### ログ確認の習慣を身につけるために

1. **エラーが出たら必ずログを確認する**
2. **エラーメッセージを最後まで読む**
3. **推測より事実（ログ）を重視する**
4. **段階的に問題を切り分ける**
5. **解決したら原因と対処法をメモする**

### 開発効率を上げるツール

- **Django Debug Toolbar**: データベースクエリやパフォーマンスの確認
- **ログレベル**: 適切なログレベルでの出力
- **IDE/エディタのデバッガ**: ブレークポイントを使った詳細確認

### 継続的な改善

- **よくあるエラーパターンを記録**: 同じ問題の再発を防ぐ
- **チーム内での情報共有**: 他のメンバーの経験から学ぶ
- **ログの改善**: より有用な情報を出力するよう改善

ログとエラーメッセージは、プログラムが私たちに送ってくれる「問題解決のヒント」です。この習慣を身につけることで、デバッグ能力が格段に向上し、自信を持って開発を進められるようになります。

最初は時間がかかっても、必ずログを確認する習慣をつけましょう。慣れてくると、エラーメッセージを見ただけで原因と解決方法がすぐにわかるようになります！
